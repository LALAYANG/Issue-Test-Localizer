{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-13496", "model_patch": "diff --git a/sklearn/ensemble/iforest.py b/sklearn/ensemble/iforest.py\nindex 17608bc..356afab 100644\n--- a/sklearn/ensemble/iforest.py\n+++ b/sklearn/ensemble/iforest.py\n@@ -133,6 +133,11 @@ class IsolationForest(BaseBagging, OutlierMixin):\n     max_samples_ : integer\n         The actual number of samples\n \n+    warm_start : bool\n+        When set to ``True``, reuse the solution of the previous call to fit\n+        and add more estimators to the ensemble, otherwise, just fit a whole\n+        new forest. See :term:`the Glossary <warm_start>`.\n+        \n     offset_ : float\n         Offset used to define the decision function from the raw scores.\n         We have the relation: ``decision_function = score_samples - offset_``.\n@@ -173,7 +178,8 @@ class IsolationForest(BaseBagging, OutlierMixin):\n                  n_jobs=None,\n                  behaviour='old',\n                  random_state=None,\n-                 verbose=0):\n+                 verbose=0,\n+                 warm_start=False):\n         super().__init__(\n             base_estimator=ExtraTreeRegressor(\n                 max_features=1,\n@@ -187,11 +193,14 @@ class IsolationForest(BaseBagging, OutlierMixin):\n             max_features=max_features,\n             n_jobs=n_jobs,\n             random_state=random_state,\n-            verbose=verbose)\n+            verbose=verbose,\n+            warm_start=warm_start)\n \n         self.behaviour = behaviour\n         self.contamination = contamination\n \n+        self.warm_start = warm_start\n+\n     def _set_oob_score(self, X, y):\n         raise NotImplementedError(\"OOB score not supported by iforest\")\n \n@@ -305,6 +314,12 @@ class IsolationForest(BaseBagging, OutlierMixin):\n \n         return self\n \n+    def fit(self, X, y=None, sample_weight=None):\n+        # Increment n_estimators if warm_start is enabled and already fitted\n+        if self.warm_start and hasattr(self, \"estimators_\"):\n+            self.n_estimators += len(self.estimators_)\n+        return super().fit(X, y, sample_weight)\n+\n     def predict(self, X):\n         \"\"\"Predict if a particular sample is an outlier or not.\n \n"}
