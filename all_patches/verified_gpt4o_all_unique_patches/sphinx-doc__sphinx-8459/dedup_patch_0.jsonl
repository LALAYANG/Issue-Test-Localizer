{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8459", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 9a0ba4a..fd3e756 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,12 +676,19 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any) -> bool:\n         return inspect.isfunction(member) or inspect.isbuiltin(member) or (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter))\n     def format_args(self, **kwargs: Any) -> str:\n-        if self.config.autodoc_typehints in ('none', 'description'):\n-            kwargs.setdefault('show_annotation', False)\n         try:\n             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n-            args = stringify_signature(sig, **kwargs)\n+            if self.config.autodoc_typehints in ('none', 'description'):\n+                kwargs.setdefault('show_annotation', False)\n+                args = stringify_signature(sig, **kwargs)\n+                for param in sig.parameters.values():\n+                    if param.annotation is not param.empty:\n+                        param.annotation = self.config.autodoc_type_aliases.get(typing.stringify(param.annotation), typing.stringify(param.annotation))\n+                if sig.return_annotation is not sig.empty:\n+                    sig.return_annotation = self.config.autodoc_type_aliases.get(typing.stringify(sig.return_annotation), typing.stringify(sig.return_annotation))\n+            else:\n+                args = stringify_signature(sig, **kwargs)\n         except TypeError as exc:\n             logger.warning(__('Failed to get a function signature for %s: %s'), self.fullname, exc)\n             return None"}
