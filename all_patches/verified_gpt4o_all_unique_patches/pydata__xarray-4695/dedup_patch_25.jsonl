{"model_name_or_path": "agentless", "instance_id": "pydata__xarray-4695", "model_patch": "diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 4b06bfd..1521d9a 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -105,7 +105,7 @@ def get_indexer_nd(index, labels, method=None, tolerance=None):\n     return indexer\n \n \n-def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=None):\n+def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=None, dim_method_name=\"method\"):\n     \"\"\"Given a pandas.Index and labels (e.g., from __getitem__) for one\n     dimension, return an indexer suitable for indexing an ndarray along that\n     dimension. If `index` is a pandas.MultiIndex and depending on `label`,\n@@ -132,7 +132,7 @@ def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=No\n                 \"unsorted or non-unique\"\n             )\n \n-    elif is_dict_like(label):\n+    elif is_dict_like(label) and index_name != dim_method_name:\n         is_nested_vals = _is_nested_tuple(tuple(label.values()))\n         if not isinstance(index, pd.MultiIndex):\n             raise ValueError(\n@@ -203,7 +203,7 @@ def convert_label_indexer(index, label, index_name=\"\", method=None, tolerance=No\n     return indexer, new_index\n \n \n-def get_dim_indexers(data_obj, indexers):\n+def get_dim_indexers(data_obj, indexers, dim_method_name=\"method\"):\n     \"\"\"Given a xarray data object and label based indexers, return a mapping\n     of label indexers with only dimension names as keys.\n \n", "occurrence": 1}
