{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-7748", "model_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 5ead82c..e24b986 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1044,17 +1044,14 @@ class DocstringSignatureMixin:\n                           RemovedInSphinx40Warning, stacklevel=2)\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n+        results = []\n         for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n             match = py_ext_sig_re.match(doclines[0])\n             if not match:\n                 continue\n             exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n             valid_names = [self.objpath[-1]]  # type: ignore\n             if isinstance(self, ClassDocumenter):\n                 valid_names.append('__init__')\n@@ -1062,14 +1059,11 @@ class DocstringSignatureMixin:\n                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n             if base not in valid_names:\n                 continue\n-            # re-prepare docstring to ignore more leading indentation\n             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n                                                         tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n-        return result\n+            results.append((args, retann))\n+        return results\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n         if encoding is not None:\n@@ -1086,9 +1080,15 @@ class DocstringSignatureMixin:\n             # only act if a signature is not explicitly given already, and if\n             # the feature is enabled\n             result = self._find_signature()\n-            if result is not None:\n-                self.args, self.retann = result\n-        return super().format_signature(**kwargs)  # type: ignore\n+            if result:\n+                self.args, self.retann = result[0]\n+        sigs = [super().format_signature(**kwargs)]\n+        if self.args is None and self.env.config.autodoc_docstring_signature:\n+            results = self._find_signature()\n+            if results:\n+                sigs = [self.format_args(**kwargs) for args, retann in results]\n+\n+        return \"\\n\".join(sigs)\n \n \n class DocstringStripSignatureMixin(DocstringSignatureMixin):\n@@ -1158,7 +1158,13 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n \n     def format_signature(self, **kwargs: Any) -> str:\n         sig = super().format_signature(**kwargs)\n-        sigs = [sig]\n+        sigs = []\n+        if self.args is None and self.env.config.autodoc_docstring_signature:\n+            results = self._find_signature()\n+            if results:\n+                sigs = [self.format_args(**kwargs) for args, retann in results]\n+        else:\n+            sigs = [sig]\n \n         if inspect.is_singledispatch_function(self.object):\n             # append signature of singledispatch'ed functions\n@@ -1634,7 +1640,13 @@ class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type:\n \n     def format_signature(self, **kwargs: Any) -> str:\n         sig = super().format_signature(**kwargs)\n-        sigs = [sig]\n+        sigs = []\n+        if self.args is None and self.env.config.autodoc_docstring_signature:\n+            results = self._find_signature()\n+            if results:\n+                sigs = [self.format_args(**kwargs) for args, retann in results]\n+        else:\n+            sigs = [sig]\n \n         meth = self.parent.__dict__.get(self.objpath[-1])\n         if inspect.is_singledispatch_method(meth):\n", "occurrence": 1}
