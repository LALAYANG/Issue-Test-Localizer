{"model_name_or_path": "agentless", "instance_id": "django__django-15161", "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 626b8ab..233a470 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1,3 +1,4 @@\n+\n import copy\n import datetime\n import functools\n@@ -651,7 +652,7 @@ class OuterRef(F):\n         return self\n \n \n-class Func(SQLiteNumericMixin, Expression):\n+class Func(SQLiteNumericMixin, models.Func):\n     \"\"\"An SQL function call.\"\"\"\n     function = None\n     template = '%(function)s(%(expressions)s)'\n@@ -731,7 +732,7 @@ class Func(SQLiteNumericMixin, Expression):\n         return copy\n \n \n-class Value(SQLiteNumericMixin, Expression):\n+class Value(SQLiteNumericMixin, models.Value):\n     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n     # Provide a default value for `for_save` in order to allow unresolved\n     # instances to be compiled until a decision is taken in #25425.\n@@ -807,7 +808,7 @@ class Value(SQLiteNumericMixin, Expression):\n         return self.value\n \n \n-class RawSQL(Expression):\n+class RawSQL(models.RawSQL):\n     def __init__(self, sql, params, output_field=None):\n         if output_field is None:\n             output_field = fields.Field()\n@@ -834,7 +835,7 @@ class RawSQL(Expression):\n         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n \n \n-class Star(Expression):\n+class Star(models.Star):\n     def __repr__(self):\n         return \"'*'\"\n \n@@ -842,7 +843,7 @@ class Star(Expression):\n         return '*', []\n \n \n-class Col(Expression):\n+class Col(models.Col):\n \n     contains_column_references = True\n     possibly_multivalued = False\n@@ -879,7 +880,7 @@ class Col(Expression):\n                 self.target.get_db_converters(connection))\n \n \n-class Ref(Expression):\n+class Ref(models.Ref):\n     \"\"\"\n     Reference to column alias of the query. For example, Ref('sum_cost') in\n     qs.annotate(sum_cost=Sum('cost')) query.\n@@ -912,7 +913,7 @@ class Ref(Expression):\n         return [self]\n \n \n-class ExpressionList(Func):\n+class ExpressionList(models.ExpressionList):\n     \"\"\"\n     An expression containing multiple expressions. Can be used to provide a\n     list of expressions as an argument to another expression, like a partition\n@@ -933,7 +934,7 @@ class ExpressionList(Func):\n         return self.as_sql(compiler, connection, **extra_context)\n \n \n-class OrderByList(Func):\n+class OrderByList(models.OrderByList):\n     template = 'ORDER BY %(expressions)s'\n \n     def __init__(self, *expressions, **extra):\n@@ -953,7 +954,7 @@ class OrderByList(Func):\n         return super().as_sql(*args, **kwargs)\n \n \n-class ExpressionWrapper(SQLiteNumericMixin, Expression):\n+class ExpressionWrapper(SQLiteNumericMixin, models.ExpressionWrapper):\n     \"\"\"\n     An expression that can wrap another expression so that it can provide\n     extra context to the inner expression, such as the output_field.\n@@ -985,7 +986,7 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n         return \"{}({})\".format(self.__class__.__name__, self.expression)\n \n \n-class When(Expression):\n+class When(models.When):\n     template = 'WHEN %(condition)s THEN %(result)s'\n     # This isn't a complete conditional expression, must be used in Case().\n     conditional = False\n@@ -1052,7 +1053,7 @@ class When(Expression):\n         return cols\n \n \n-class Case(SQLiteNumericMixin, Expression):\n+class Case(SQLiteNumericMixin, models.Case):\n     \"\"\"\n     An SQL searched CASE expression:\n \n@@ -1133,7 +1134,7 @@ class Case(SQLiteNumericMixin, Expression):\n         return super().get_group_by_cols(alias)\n \n \n-class Subquery(BaseExpression, Combinable):\n+class Subquery(models.Subquery):\n     \"\"\"\n     An explicit subquery. It may contain OuterRef() references to the outer\n     query which will be resolved when it is applied to that query.\n@@ -1190,7 +1191,7 @@ class Subquery(BaseExpression, Combinable):\n         return self.query.get_group_by_cols()\n \n \n-class Exists(Subquery):\n+class Exists(models.Exists):\n     template = 'EXISTS(%(subquery)s)'\n     output_field = fields.BooleanField()\n \n@@ -1225,7 +1226,7 @@ class Exists(Subquery):\n         return sql, params\n \n \n-class OrderBy(Expression):\n+class OrderBy(models.OrderBy):\n     template = '%(expression)s %(ordering)s'\n     conditional = False\n \n@@ -1307,7 +1308,7 @@ class OrderBy(Expression):\n         self.descending = True\n \n \n-class Window(SQLiteNumericMixin, Expression):\n+class Window(SQLiteNumericMixin, models.Window):\n     template = '%(expression)s OVER (%(window)s)'\n     # Although the main expression may either be an aggregate or an\n     # expression with an aggregate function, the GROUP BY that will\n@@ -1412,7 +1413,7 @@ class Window(SQLiteNumericMixin, Expression):\n         return []\n \n \n-class WindowFrame(Expression):\n+class WindowFrame(models.WindowFrame):\n     \"\"\"\n     Model the frame clause in window expressions. There are two types of frame\n     clauses which are subclasses, however, all processing and validation (by no\n@@ -1471,14 +1472,14 @@ class WindowFrame(Expression):\n         raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n \n \n-class RowRange(WindowFrame):\n+class RowRange(models.RowRange):\n     frame_type = 'ROWS'\n \n     def window_frame_start_end(self, connection, start, end):\n         return connection.ops.window_frame_rows_start_end(start, end)\n \n \n-class ValueRange(WindowFrame):\n+class ValueRange(models.ValueRange):\n     frame_type = 'RANGE'\n \n     def window_frame_start_end(self, connection, start, end):\n", "occurrence": 1}
