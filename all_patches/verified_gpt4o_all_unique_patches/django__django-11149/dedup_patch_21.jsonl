{"model_name_or_path": "agentless", "instance_id": "django__django-11149", "model_patch": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex b043b1a..f932d85 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1001,35 +1001,38 @@ class InlineModelAdmin(BaseModelAdmin):\n         exclude = exclude or None\n         can_delete = self.can_delete and self.has_delete_permission(request, obj)\n         defaults = {'form': self.form, 'formset': self.formset, 'fk_name': self.fk_name, 'fields': fields, 'exclude': exclude, 'formfield_callback': partial(self.formfield_for_dbfield, request=request), 'extra': self.get_extra(request, obj, **kwargs), 'min_num': self.get_min_num(request, obj, **kwargs), 'max_num': self.get_max_num(request, obj, **kwargs), 'can_delete': can_delete, **kwargs}\n-        base_model_form = defaults['form']\n-        can_change = self.has_change_permission(request, obj) if request else True\n-        can_add = self.has_add_permission(request, obj) if request else True\n-        class DeleteProtectedModelForm(base_model_form):\n-            def hand_clean_DELETE(self):\n-                if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n-                    using = router.db_for_write(self._meta.model)\n-                    collector = NestedObjects(using=using)\n-                    if self.instance._state.adding:\n-                        return\n-                    collector.collect([self.instance])\n-                    if collector.protected:\n-                        objs = []\n-                        for p in collector.protected:\n-                            objs.append(_('%(class_name)s %(instance)s') % {'class_name': p._meta.verbose_name, 'instance': p})\n-                        params = {'class_name': self._meta.model._meta.verbose_name, 'instance': self.instance, 'related_objects': get_text_list(objs, _('and'))}\n-                        msg = _('Deleting %(class_name)s %(instance)s would require deleting the following protected related objects: %(related_objects)s')\n-                        raise ValidationError(msg, code='deleting_protected', params=params)\n-            def is_valid(self):\n-                result = super().is_valid()\n-                self.hand_clean_DELETE()\n-                return result\n-            def has_changed(self):\n-                if not can_change and (not self.instance._state.adding):\n-                    return False\n-                if not can_add and self.instance._state.adding:\n-                    return False\n-                return super().has_changed()\n-        defaults['form'] = DeleteProtectedModelForm\n+        if not self.has_change_permission(request, obj):\n+            defaults['form'] = readonly_inlineformset_factory(self.parent_model, self.model, **defaults)\n+        else:\n+            base_model_form = defaults['form']\n+            can_change = self.has_change_permission(request, obj) if request else True\n+            can_add = self.has_add_permission(request, obj) if request else True\n+            class DeleteProtectedModelForm(base_model_form):\n+                def hand_clean_DELETE(self):\n+                    if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n+                        using = router.db_for_write(self._meta.model)\n+                        collector = NestedObjects(using=using)\n+                        if self.instance._state.adding:\n+                            return\n+                        collector.collect([self.instance])\n+                        if collector.protected:\n+                            objs = []\n+                            for p in collector.protected:\n+                                objs.append(_('%(class_name)s %(instance)s') % {'class_name': p._meta.verbose_name, 'instance': p})\n+                            params = {'class_name': self._meta.model._meta.verbose_name, 'instance': self.instance, 'related_objects': get_text_list(objs, _('and'))}\n+                            msg = _('Deleting %(class_name)s %(instance)s would require deleting the following protected related objects: %(related_objects)s')\n+                            raise ValidationError(msg, code='deleting_protected', params=params)\n+                def is_valid(self):\n+                    result = super().is_valid()\n+                    self.hand_clean_DELETE()\n+                    return result\n+                def has_changed(self):\n+                    if not can_change and (not self.instance._state.adding):\n+                        return False\n+                    if not can_add and self.instance._state.adding:\n+                        return False\n+                    return super().has_changed()\n+            defaults['form'] = DeleteProtectedModelForm\n         if defaults['fields'] is None and (not modelform_defines_fields(defaults['form'])):\n             defaults['fields'] = forms.ALL_FIELDS\n         return inlineformset_factory(self.parent_model, self.model, **defaults)"}
